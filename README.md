

# Parking Rates API


## Table of Contents
- [Installation](#installation)
- [Endpoints](#endpoints)
- [Running Tests](#running-tests)
- [Assumptions](#assumptions)
- [Limitations](#limitations)
- [Improvements](#improvements)
- [Credits](#credits)


## Installation

Setup requirements:
- Python 3.12
- Poetry 1.8.2


##### To easily setup for the first time and run the server:
```bash
chmod +x run_app.sh
./run_app.sh
```


##### Then feel free to start the server with the following:
```python
./manage.py runserver {PORT number}
```
==Note: This application is configured to run on port 5000 by default; however you may already have a process running on that port. In which case, please enter a different port==


## Endpoints

#### GET /api/rates/
- Description: Retrieve a list of all rates.
- Parameters: None
- Response:
```json
[
    {
        "days": "mon,tues,thurs",
        "times": "0900-2100",
        "tz": "America/Chicago",
        "price": 1500
    },
    {
        "days": "fri,sat,sun",
        "times": "0900-2100",
        "tz": "America/Chicago",
        "price": 2000
    }
]
```


#### PUT /api/rates/
- Description: Updates existing parking rate instance.
- Parameters:
    - `days` (string): Shorthand days of the week, separated by a comma, and without any spaces
    - `times` (string): Local time range; the first number being the start time and the number following the `-` is the end time
        - Must be in 0000-0000 format
        - The start time must occur before the end time
    - `tz` (string): Name of timezone the `times` field is in
        - `tz` must match a timezone listed [here](https://gist.github.com/JellyWX/913dfc8b63d45192ad6cb54c829324ee)
    - `price` (integer): New price to update rate with

- Request Body:
    ```json
    {
        "days": "mon,wed,sat",
        "times": "0200-0600",
        "tz": "America/New_York",
        "price": 2500
    }
    ```

- Response: Returns new price
    ```json
    {
        "price": 2500
    }
    ```
    - If the given rate does not exist, you will receive the following message:
    `"No instance found to update"`
    - If the given rate has the same data as the found rate, then there is nothing to update:
    `"Given data matches perfectly - nothing to update`

#### GET /api/price/
- Description: Request the price for a given ISO-8601 time range.
- Parameters:
    - `start` (string): Start datetime in ISO-8601 format
    - `end` (string): End datetime in ISO-8601 format
- Query Parameters:
    `?start=2015-07-01T07:00:00-05:00&end=2015-07-01T12:00:00-05:00`
- Response: If found, returns the price 
    ```json
    {
        "price": 1750
    }
    ```
    - If there was nothing found in the given time range or the time range spans over a day, the response will be:
    `"unavailable"`


## Running Tests

To run the tests, make sure dev dependencies are installed first.
Then, simply enter:

```bash
pytest {optional: route to specific test or test suite}
```
==Note: A route to a specific test, test suite, or file, can be used as an argument==

Test coverage is generated by default. After running `pytest`, take a look at the `htmlcov` folder that is generated, open `index.html`, then right click and click `Open preview`
==Note: this is the correct flow for VSCode, but you may find slightly different steps if using PyCharm==


## Assumptions

1. **Intended consumer of API is the frontend.** 
- Given that this behavior allows users to alter their rates, I’m assuming this API will be consumed by the in-house FE team and is NOT a customer facing white-label service.

2. **/price endpoint returns prices that are in the past.**
- In the SpotHero app, you can only reserve spots that are in the future; however, the documentation does not state this is a requirement so I left it out.
    - I.e. validation could be enforced on this endpoint to ensure an ISO-8601 datetime does not include a date in the past. For example:
    `“?start=2015-07-01T07:00:00-05:00&end=2015-07-01T12:00:00-05:00”` would throw an error, because we are not remotely in the year of 2015.

3. **Structure/data types/naming conventions in sample JSON are not a strict requirement for storing values.**
- I.e. In one of the given examples: `"times": "0900-2100"` does not require a model field/column named `“times”` and any example of a time does not need to be a char/string type.

4. **No authentication is required.**
- In a real world scenario, we would never allow a user to update rates that may or may not belong to his/her establishment. Authentication was not in scope and, as such, was left out of the solution.

5. **Upserts not considered.**
- `/rates` endpoint only updates existing rates and does not insert if that rate is not found. I assume in a real world scenario, we would want to allow users to create new rate rules, insofar as they do not overlap. Since this was not an explicit requirement, it was left out of scope.

6. **SQLite is an appropriate database.**
- This database is an appropriate option for this small amount of data. There is also the added benefit of simplicity, where installing, starting the service, then creating a Postgres or MySQL database is not required to run this application.
    - I intended to reduce friction where possible.

7. **Hiding keys is always good practice.**
- Adhering to industry standards, I do not commit potentially sensitive stuff, though I fully realize that creating an environment variable for the Django SECRET KEY is probably overkill for this scenario.

## Limitations

1. **Data sent in PUT `/rates` must match an existing instance exactly in order to be updated**
- I.e. days `“mon,wed,fri”` MUST match exactly in order to be updated. `“Wed,fri,mon”` in the request body would not update.


## Improvements
1. Better handling of `"days"`
- Matching character fields in a database is not performant. 
    - An alternative would be to create a relationship table, where days of the week are linked with their specific rate rule. 
    - Or, use PostgreSQL to turn the `"days"` char field into an ArrayField. I decided to make things simple and just use the default sqlite, which does not support ArrayField types.

2. Unused model fields
    - References to the given times, time range, and timezone aren't really necessary as they have not been used anywhere. 
    - However, an opposing argument could be that more data is better because we can never get the data back once it's gone.

3. Audit logs
    - If there is an opportunity for a user to update some existing field, then keeping an audit log of those changes, along with when the change occurred and by whom, is always a good idea. 


## Credits

##### A special thank you to:

- the team at SpotHero for reviewing my work. I had a lot of fun thinking through this problem and welcome your feedback.
- [open source libraries and the brains behind them](https://qph.cf2.quoracdn.net/main-qimg-ea57b52aff0903332036ada67f05d3f6) that have created these frameworks and libraries that we all use, free of charge.
- the folks that I have worked with in the past that have taken me under their wing. I am eternally grateful.
